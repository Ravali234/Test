#!/usr/bin/python
# -*- coding: utf-8 -*-
##
# control_console.py: Provides a graphical control console for interacting
#     with X6-1000M boards.
##
# Author: Christopher Granade (cgranade@cgranade.com).
##

## IMPORTS ####################################################################

import matplotlib
# Ensure that matplotlib is using Qt, so that the event loop is compatible.
matplotlib.use('Qt4Agg')
# Solve issue mentioned at:
# http://stackoverflow.com/questions/6723527/getting-pyside-to-work-with-matplotlib
matplotlib.rcParams['backend.qt4'] = 'PySide'
# Actually import pyplot now that the backend is correct.
import matplotlib.pyplot as plt

import x6

import os, sys
import tempfile
import subprocess

from PySide import QtGui
from x6.tools.ui import control_gui
from x6 import pulplot, pulprog, utils

import ConfigParser as cp

# This needs to be done in order for the Windows task bar to group this 
# program separately from the IPython icon.
# http://stackoverflow.com/questions/1551605/how-to-set-applications-taskbar-icon
if sys.platform.startswith('win'):
    import ctypes
    myappid = 'corylab.hardwaredrivers.x6.controlconsole' # arbitrary string
    ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

## FUNCTIONS ##################################################################

def tablewidget_text(tb_widget, row, col):
    item = tb_widget.item(row, col)
    if item is None:
        return None
    else:
        return item.text()

## CLASSES ####################################################################

class MainWindow(QtGui.QMainWindow):
    def __init__(self, parent=None):
        # Call the superclass constructor.
        super(MainWindow, self).__init__(parent)
        
        # Inflate the UI generated by pyside-uic.
        self._ui = control_gui.Ui_MainWindow()
        self._ui.setupUi(self)
        
        # Attach event handlers to the appropriate signals.
        self._ui.btn_open.clicked.connect(self.on_btn_open)
        self._ui.btn_close.clicked.connect(self.on_btn_close)
        self._ui.btn_preconfigure.clicked.connect(self.on_btn_preconfigure)
        self._ui.btn_start.clicked.connect(self.on_btn_start)
        self._ui.btn_stop.clicked.connect(self.on_btn_stop)
        self._ui.btn_preview.clicked.connect(self.on_btn_preview)
        self._ui.btn_view_config.clicked.connect(self.on_btn_view_config)
        self._ui.btn_compile_pulprog.clicked.connect(self.compile_)
        self._ui.btn_edit_pulprog.clicked.connect(self.on_btn_edit_pulprog)
        self._ui.le_config_file.editingFinished.connect(self.on_config_file_edited)
        self._ui.btn_browse_config_file.clicked.connect(self.browse_for(self._ui.le_config_file))
        self._ui.btn_browse_pulprog_file.clicked.connect(self.browse_for(self._ui.le_pulprog_file))
        self._ui.tab_parameters.cellChanged.connect(self.on_param_cell_changed)
        self._ui.cmb_pulse_name.currentIndexChanged.connect(self.on_pulse_name_changed)

        # Define short event handlers inline using lambdas.
        self._ui.btn_add_param.clicked.connect(lambda:
            self._ui.tab_parameters.insertRow(self._ui.tab_parameters.rowCount())
        )
        self._ui.btn_del_param.clicked.connect(lambda:
            self._ui.tab_parameters.removeRow(self._ui.tab_parameters.currentRow())
        )
        
        # Create a new driver.
        self._driver = x6.X6()
        
        # Update the buttons according to the driver's initial state.
        self._update_btnstates()
        
        # Remember whether the configuration is "dirty."
        # That is, if it needs pushed to the device at the next opportunity
        # or not.
        self._conf_dirty = True
        
        # Remember whether or not the pulprog has been compiled.
        self._compile_dirty = True
        
        # Keep track of where we most recently compiled to.
        self._compile_dir = None
        
        # Load user settings in x6settings.ini
        self._settings = utils.X6Settings()

    def _update_btnstates(self):
        if self._driver.is_open:
            self._ui.btn_open.setEnabled(False)
            self._ui.btn_close.setEnabled(True)
            if self._driver.is_streaming:
                self._ui.btn_start.setEnabled(False)
                self._ui.btn_stop.setEnabled(True)
                self._ui.btn_preconfigure.setEnabled(False)
            else:
                self._ui.btn_start.setEnabled(True)
                self._ui.btn_stop.setEnabled(False)
                self._ui.btn_preconfigure.setEnabled(True)
        else:            
            self._ui.btn_open.setEnabled(True)
            self._ui.btn_close.setEnabled(False)
            self._ui.btn_start.setEnabled(False)
            self._ui.btn_stop.setEnabled(False)
            self._ui.btn_preconfigure.setEnabled(False)    
        
    def console_print(self, text):
        self._ui.te_console.appendPlainText(str(text))
        
    def report(self, context, ex):
        self.console_print(
            "Exception {kind} occured while {context}:\n    {msg}".format(
                kind=type(ex), context=context, msg=ex.message
            )
        )
       
    def compile_(self):
        try:
            pulseprog_file = self._ui.le_pulprog_file.text()
            
            if len(pulseprog_file) == 0:
                self.console_print('No pulse program selected.')
                return
            
            # This way, if we fail in the middle,
            # we know to recompile next time.
            self._compile_dirty = True
            self._conf_dirty = True
            
            # Delete any previous compilation attempts, ignoring errors.
            # It's a temporary directory after all.
            if self._compile_dir is not None:
                try:
                    shutil.rmtree(self._compile_dir)
                except:
                    pass
                
            # Make a new directory to hold the compiled output.
            self._compile_dir = tempfile.mkdtemp()
            self.console_print("Compiling to {}...".format(self._compile_dir))
            
            # Find and open the source file.
            with open(pulseprog_file, 'r') as source_file:
                
                # Actually perform the compilation.
                pulprog.compile_to_directory(source_file, self._compile_dir)
            
            # Mark that we completed successfully.
            self._compile_dirty = False
            
            self.console_print('Done.')
            
        except Exception as ex:
            self.report("compiling", ex)
            raise
       
    def reconfigure(self):
        # Configure differently if loading from a pulse config file
        # or a pulprog.
        try:
            if self._ui.rbtn_from_config.isChecked():
                self._driver.load_configuration(
                    conf_file=self._ui.le_config_file.text(),
                    section=self._ui.cmb_pulse_name.currentText()
                )
                if self._ui.tab_parameters.rowCount() != 0:
                    for idx_row in xrange(self._ui.tab_parameters.rowCount()):
                        name = tablewidget_text(self._ui.tab_parameters, idx_row, 0)
                        value = tablewidget_text(self._ui.tab_parameters, idx_row, 1)
                        if name: # Skip blank names.
                            if hasattr(self._driver, name):
                                try:                            
                                    setattr(self._driver, name, value)
                                except Exception as ex:
                                    self.report("setting {}".format(name), ex)
                            else:
                                self.console_print("No such parameter {}.".format(name))
            else:
                if self._compile_dirty:
                    self.compile_()
                config_file = os.path.join(self._compile_dir, 'pulse.pulse')
                pulse_name = 'Compiled Pulse'
                self._driver.load_configuration(
                    conf_file=config_file,
                    section=pulse_name
                )
        
            # If we successfully reconfigured, mark that there's no further
            # changes that we need to push.
            self._conf_dirty = False
            self.console_print("Configuration uploaded to board.")
            
        except Exception as ex:
            self.report("configuring board", ex)
        
    def browse_for(self, widget):
        def callback():
            # Make a new dialog that can select any existing file.
            dialog = QtGui.QFileDialog()
            dialog.setFileMode(QtGui.QFileDialog.ExistingFile)
            
            # If the dialog completes successfully (isn't cancelled),
            # set the file accordingly and emit a signal to trigger
            # callbacks attached to editing.
            if dialog.exec_():
                widget.setText(dialog.selectedFiles()[0])
                widget.editingFinished.emit()
                
        return callback
        
    def on_btn_open(self):
        try:
            self._driver.open()

            # Redirty the configuration.
            self._conf_dirty = True
            
            # Print out the logic version--- useful for debugging.
            self.console_print("Opened board with logic version:")
            self.console_print(self._driver.logic_version())
        except Exception as ex:
            self.report("opening board", ex)
        finally:
            self._update_btnstates()
    
    def on_btn_close(self):
        try:
            self._driver.close()
        except Exception as ex:
            self.report("closing board", ex)
        finally:
            self._update_btnstates()
            
    def on_btn_preconfigure(self):        
        if self._conf_dirty:
            self.reconfigure()
            
        # TODO: catch debug output from the driver..
        try:                
            self._driver.preconfigure()
            self.console_print("Successfully preconfigured.")
        except Exception as ex:
            self.report("preconfiguring", ex)
            
    def on_btn_preview(self):
        if self._ui.rbtn_from_config.isChecked():
            config_file = self._ui.le_config_file.text()
            pulse_name = self._ui.cmb_pulse_name.currentText()
        else:
            if self._compile_dirty:
                self.compile_()
            config_file = os.path.join(self._compile_dir, 'pulse.pulse')
            pulse_name = 'Compiled Pulse'
            
        try:
            pulplot.plot_configuration_file(config_file, pulse_name)
            plt.show()
        except Exception as ex:
            self.report("previewing", ex)
            
    def on_btn_start(self):
        if self._conf_dirty:
            self.reconfigure()
            
        try:                
            self._driver.start_streaming()
        except Exception as ex:
            self.report("starting", ex)
        finally:
            self._update_btnstates()

    def on_btn_stop(self):
        try:
            self._driver.stop_streaming()
        except Exception as ex:
            self.report("stopping", ex)
        finally:
            self._update_btnstates() 
            
    def on_config_file_edited(self):
        try:
            self._ui.cmb_pulse_name.clear()
            parser = cp.SafeConfigParser()
            parser.read(self._ui.le_config_file.text())
            for section_name in parser.sections():
                self._ui.cmb_pulse_name.addItem(section_name)
        except IOError as ex:
            self.report("loading configuration file", ex)
            
    def on_param_cell_changed(self, row, col):
        # This isn't a lambda as lambdas can't contain assignments
        # unless you use setattr(), but that just feels wrong.
        self._conf_dirty = True
        
    def on_pulse_name_changed(self, idx):
        self._conf_dirty = True
        
    def on_btn_edit_pulprog(self):
        
        text_editor = self._settings.control_console_file_editor;
        source_file = self._ui.le_pulprog_file.text()

        if len(source_file) == 0:
            self.console_print("No source file selected.")
            return
        
        if not text_editor is None:
            try:
                subprocess.Popen([text_editor, source_file])
            except Exception as ex:
                self.report('Error editing source code.', ex)
        else:
            self.console_print("No text editor has been saved in the settings file 'x6settings.ini'.")
            
    def on_btn_view_config(self):
        
        text_editor = self._settings.control_console_file_editor;
        
        if self._ui.rbtn_from_config.isChecked():
            config_file = self._ui.le_config_file.text()
        else:
            if self._compile_dirty:
                self.compile_()
            config_file = os.path.join(self._compile_dir, 'pulse.pulse')            

        if len(config_file) == 0:
            self.console_print("No configuration file available.")
            return

        if not text_editor is None:
            try:
                subprocess.Popen([text_editor, config_file])
            except Exception as ex:
                self.report('Error editing source code.', ex)
        else:
            self.console_print("No text editor has been saved in the settings file 'x6settings.ini'.")

            
## MAIN #######################################################################

if __name__ == "__main__":
    app = QtGui.QApplication('"X6-1000M Control Console"')
    app.setApplicationName("X6-1000M Control Console")
    
    main_win = MainWindow()
    main_win.show()
    
    icon_path = utils.find_on_path('x6/tools/ui/icon.png')
    app.setWindowIcon(QtGui.QIcon(icon_path))
    main_win.setWindowIcon(QtGui.QIcon(icon_path))
    
    app.exec_()
